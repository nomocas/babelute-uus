{"version":3,"file":"index.js","sources":["../../../babelute/src/babelute.js","../../../babelute/src/lexicon/first-level.js","../../../babelute/src/lexicon/initializer.js","../../../babelute/src/lexicon/lexicon.js","../../../babelute/src/pragmatics/pragmatics-core.js","../../../babelute/src/pragmatics/facade-pragmatics.js","../../../babelute/src/index.js","../../src/to-uus.js","../../../elenpi/dist/index.mjs","../../src/from-uus.js","../../src/index.js"],"sourcesContent":["/**\n * Babelute core\n *\n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2016-2017 Gilles Coomans\n */\n\nimport assert from 'assert'; // removed in production\n\n/**\n * Lexem class : a lexem is just an object containing 3 properties { lexicon:String, name:String, args:Arguments|Array }\n * You should never construct them directly (but if you do babelute's plugins). And it should never be extended.\n * @protected\n */\nexport class Lexem {\n\n\t/**\n\t * construct a new lexem instance\n\t * @param  {String} lexicon the lexicon's name of the lexem\n\t * @param  {String} name    the lexem's name\n\t * @param  {Array|arguments} args  the lexem's arguments (an array or the \"callee arguments\" object) \n\t */\n\tconstructor(lexicon, name, args) {\n\t\tassert(typeof lexicon === 'string' && lexicon.length, 'Lexicon\\'s name should be a valid string');\n\t\tassert(typeof name === 'string' && lexicon.length, 'Lexem\\'s name should be a valid string');\n\t\tassert(Array.isArray(args) || typeof args.length !== 'undefined', 'Lexem\\'s args should be an array (or iterable with bracket access)');\n\n\t\t/**\n\t\t * the lexicon name from where the lexem comes\n\t\t * @type {String}\n\t\t */\n\t\tthis.lexicon = lexicon;\n\n\t\t/**\n\t\t * the lexem's name\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The lexem's arguments array (or arguments object)\n\t\t * @type {Array|arguments}\n\t\t */\n\t\tthis.args = args;\n\t}\n}\n\n/**\n * Babelute subclass(es) instances : for holding array of lexems (i.e. a sentence) written through the DSL's API.\n *\n * Will be the base class for all DSLs handlers.\n *\n * Babelute API and lexems Naming Conventions : \n * \n * - any \"meta-language\" method (aka any method that handle the sentence it self - appending new lexem, changing current lexicon, sentences translations, ...) \n * must start with and underscore : e.g. _append, _lexicon, _if,  _each, _eachLexem, _translate...\n * - any \"pragmatics output related\" method should start with a '$' and should be named with followed format : e.g. .$myLexiconToMyOutputType(...)\n * - any DSL lexems (so any other \"api\"'s method) should start with a simple alphabetic char : e.g. .myLexem(), .description(), .title(), ...\n * \t\t\n * @public\n */\nexport class Babelute {\n\n\t/**\n\t * construct a babelute instance\n\t * @param  {?Array} lexems array of lexems for init. (only for internal use)\n\t */\n\tconstructor(lexems = null) {\n\t\tassert(!lexems || Array.isArray(lexems), 'Babelute\\'s constructor accept only an array of lexems as argument (optionaly)');\n\n\t\t/**\n\t\t * the array where lexems are stored\n\t\t * @type {Array}\n\t\t */\n\t\tthis._lexems = lexems || [];\n\n\t\t/**\n\t\t * useful marker for fast instanceof replacement (frame/multiple-js-runtime friendly)\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.__babelute__ = true;\n\t}\n\n\t/**\n\t * The absolute Babelute atom method : add a lexem to babelute's array\n\t * @public\n\t * @param  {String} lexiconName the current lexicon name\n\t * @param  {String} name      the lexem's name\n\t * @param  {Array|arguments} args   the lexem's arguments (either an array or maybe directly the arguments object from when lexem is called)\n\t * @return {Babelute} \tthe current Babelute instance\n\t */\n\t_append(lexiconName, name, args) {\n\n\t\tthis._lexems.push(new Lexem(lexiconName, name, args));\n\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * conditional sentences concatenation.\n\t *\n\t * Apply modification at sentence writing time (aka the babelute does not contains the _if lexems. _if has immediatly been applied).\n\t * \n\t * @public\n\t * @param  {*} condition any value that will be casted to Boolean (!!)\n\t * @param  {Babelute} babelute  which sentence to insert if !!condition === true\n\t * @param  {?Babelute} elseBabelute  which sentence to insert if !!condition === false\n\t * @return {Babelute}     the current Babelute instance\n\t */\n\t_if(condition, babelute, elseBabelute = null) {\n\n\t\tassert(babelute instanceof Babelute, '._if meta-api need an babelute instance as second argument');\n\t\tassert(!elseBabelute || elseBabelute instanceof Babelute, '._if meta-api need an babelute instance as third argument (optional)');\n\n\t\tif (condition)\n\t\t\tthis._lexems = this._lexems.concat(babelute._lexems);\n\t\telse if (elseBabelute)\n\t\t\tthis._lexems = this._lexems.concat(elseBabelute._lexems);\n\t\treturn this;\n\t}\n\n\t/**\n\t * For each item from array : execute function and concatenate returned babelute sentence to current one. \n\t * Provided function must return a babelute.\n\t *\n\t * Apply modification at sentence writing time (aka the babelute does not contains the _each lexems. _each has immediatly been applied).\n\t * \n\t * @public\n\t * @param  {Array} array  the array to iterate on\n\t * @param  {Function} func the function to handle each item. it must return a babelute.\n\t * @return {Babelute}     the current Babelute instance\n\t */\n\t_each(array, func) {\n\n\t\tassert(Array.isArray(array) || array.length, '._each meta-api need an array (or iterable with bracket access) as first argument');\n\t\tassert(typeof func === 'function', '._each meta-api need a function as second argument');\n\n\t\tarray.forEach((item, index) => {\n\t\t\tconst b = func(item, index);\n\n\t\t\tassert(b instanceof Babelute, '._each need a function that return a babelute');\n\n\t\t\tthis._lexems.push.apply(this._lexems, b._lexems);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a babelute (another sentence) at this point in the current sentence\n\t * @public\n\t * @param  {string|Babelute} babelute Either a string formatted as 'mylexicon:myMethod' (which gives the lexem's method to call), or a Babelute instance (which will be inserted in current sentence)\n\t * @param  {?...args} args the optional arguments to use when calling lexem (only if first argument is a string)\n\t * @return {Babelute} the current Babelute instance\n\t * @throws {Error} If lexicon not found (when first arg is string)\n\t * @throws {Error} If method not found in lexicon (when first arg is string)\n\t */\n\t_use(babelute, ...args) { // eslint-disable-line no-unused-vars\n\t\t// will be implemented in lexicon\n\t}\n\n\n\t/**\n\t * Change current lexicon for next lexems\n\t * @public\n\t * @param  {string} lexiconName the lexicon to use\n\t * @return {Babelute}  a new Babelute from lexicon (i.e. with lexicon's API)\n\t * @throws {Error} If lexicon not found with lexiconName\n\t */\n\t_lexicon(lexiconName) { // eslint-disable-line no-unused-vars\n\t\tassert(typeof lexiconName === 'string', '._lexicon need a string as first argument');\n\t\t// will be implemented in lexicon\n\t}\n\n\t/**\n\t * Create Babelute subclass\n\t * @param  {Babelute} BaseClass the class to be extended\n\t * @param  {?Object} api an object containing methods to add to prototype\n\t * @return {Babelute}   The subclass\n\t * @throws {AssertionError} (only in dev mode) If BaseClass is not a Babelute Subclass (or Babelute)\n\t */\n\tstatic extends(BaseClass, api = null) {\n\t\tassert(BaseClass === Babelute || (BaseClass.prototype instanceof Babelute), 'Babelute.extends accepts only a Babelute Class (or subclass) as first argument');\n\t\tassert(!api || typeof api === 'object', 'Babelute.extends need a (optional) valid object containing methods as second argument');\n\t\tconst B = function(lexems) {\n\t\t\tBaseClass.call(this, lexems);\n\t\t};\n\t\tB.prototype = Object.create(BaseClass.prototype);\n\t\tB.prototype.constructor = B;\n\t\tfor (var i in api) // Object.assign seems to bug when used on prototype (not investigate enough : so use plain old for-in syntax)\n\t\t\tB.prototype[i] = api[i];\n\t\treturn B;\n\t}\n}\n\n\n/**\n * deserialize json to babelute\n * @param  {String} json the json string\n * @return {Babelute}      the deserialized babelute\n * @throws {Error} If json is badly formated\n */\nexport function fromJSON(json) {\n\tassert(typeof json === 'string', 'babelute.fromJSON need a string as first argument');\n\treturn JSON.parse(json, (k, v) => {\n\t\tif (v && v.__babelute__)\n\t\t\treturn new Babelute(v._lexems.map((lexem) => {\n\t\t\t\treturn new Lexem(lexem.lexicon, lexem.name, lexem.args);\n\t\t\t}));\n\t\treturn v;\n\t});\n}\n\n","/**\n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2017 Gilles Coomans\n */\n\nimport assert from 'assert'; // removed in production\nimport {\n\tBabelute,\n\tLexem\n} from '../babelute.js';\n\n/**\n * A FirstLevel is a Babelute that has exactly same api than its corresponding Babelute (from a DSL) but where every compounds methods has been replaced by its \"atomic\" equivalent.\n * (Same concept than 'first-level of understanding', as if we where stupid by always understanding only first literal sens of words.)\n * \n * It provides sentences and lexems without any interpretation, and that could be really useful : e.g.\n * - to see sentence as \"editable document\" and/or for allowing meta-writing of sentences\n * - to obtain the full AST of babelute sentences \n * \n * @access protected\n */\nexport default class FirstLevel extends Babelute {\n\n\t/**\n\t * construct a firstlevel babelute instance\n\t * @param  {?Array} lexems array of lexems for init. (only for internal use)\n\t */\n\tconstructor(lexems) {\n\t\tsuper(lexems);\n\t\tthis.__first_level_babelute__ = true;\n\t}\n\n\t/**\n\t * return a FirstLevelMethod aka a method that only append an atom (lexicon, name, args)\n\t * @param  {String} lexiconName the lexicon name of the appended atom\n\t * @param  {String} lexemName  the lexem name of the appended atom\n\t * @return {Function}           a function that append the atom\n\t */\n\tstatic getFirstLevelMethod(lexiconName, lexemName) {\n\t\tassert(typeof lexiconName === 'string', 'FirstLevel.getFirstLevelMethod(...) need a string (the lexicon name) as first argument');\n\t\tassert(typeof lexemName === 'string', 'FirstLevel.getFirstLevelMethod(...) need a string (the lexem name) as second argument');\n\t\treturn function () {\n\t\t\tthis._lexems.push(new Lexem(lexiconName, lexemName, arguments));\n\t\t\treturn this;\n\t\t};\n\t}\n}","/*\n* @Author: Gilles Coomans\n* @Date:   2017-03-10 13:25:25\n* @Last Modified by:   Gilles Coomans\n* @Last Modified time: 2017-03-10 22:31:48\n*/\n\nimport assert from 'assert'; // removed in production\n\nimport {\n\tBabelute\n} from '../babelute.js';\n\n/**\n * Initializer Class\n * @protected\n */\nclass Initializer {\n\t/**\n\t * extends Initializer\n\t * @param  {[type]} BaseInitializer [description]\n\t * @return {[type]}                 [description]\n\t */\n\tstatic extends(BaseInitializer) {\n\n\t\tassert(BaseInitializer === Initializer || (BaseInitializer.prototype instanceof Initializer), 'Initializer.extends accepts only a Initializer Class (or subclass) as argument');\n\n\t\tconst Class = function() {};\n\t\tClass.prototype = Object.create(BaseInitializer.prototype);\n\t\tClass.prototype.constructor = Class;\n\t\treturn Class;\n\t}\n}\n\n/**\n * create a Initializer (based on a Babelute subclass) and instanciate it\n * @param  {Babelute} BabeluteClass   a Babelute subclass from where create initializer\n * @param  {?Initializer} BaseInitializer a parent initializer to be extended (optional)\n * @return {Initializer}               the Initializer instance\n * @protected\n */\nfunction createInitializer(BabeluteClass, BaseInitializer = null) {\n\n\tassert(BabeluteClass === Babelute || (BabeluteClass.prototype instanceof Babelute), 'Lexicon createInitializer accepts only a Babelute Class (or subclass) as first argument');\n\tassert(!BaseInitializer || BaseInitializer === Initializer || (BaseInitializer.prototype instanceof Initializer), 'Lexicon createInitializer accepts only a Initializer Class (or subclass) as second argument');\n\n\tconst Init = BabeluteClass.Initializer = BaseInitializer ? Initializer.extends(BaseInitializer) : Initializer;\n\tBabeluteClass.initializer = new Init();\n\tBabeluteClass.initializer._empty = function() {\n\t\treturn new BabeluteClass();\n\t};\n\tBabeluteClass.initializer.BabeluteClass = BabeluteClass;\n\tObject.keys(BabeluteClass)\n\t\t.forEach((i) => {\n\t\t\taddToInitializer(Init, i);\n\t\t});\n\treturn BabeluteClass.initializer;\n}\n\n/**\n * add method to initializer\n * @protected\n * @param {Initializer} Initializer Initializer class where add methods in proto\n * @param {string} methodName  the name of method to add\n */\nfunction addToInitializer(Initializer, methodName) {\n\tInitializer.prototype[methodName] = function() {\n\t\treturn this.BabeluteClass.prototype[methodName].apply(new this.BabeluteClass(), arguments);\n\t};\n}\n\n\nexport {\n\tInitializer,\n\tcreateInitializer,\n\taddToInitializer\n};\n\n","/**\n * Babelute Lexicon class and helpers.\n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2016-2017 Gilles Coomans\n */\n\nimport assert from 'assert'; // removed in production\nimport { Babelute, Lexem } from '../babelute.js';\nimport FirstLevel from './first-level.js';\nimport { addToInitializer, createInitializer } from './initializer.js';\n\n/**\n * Lexicons dico : where to store public lexicon\n * @type {Object}\n * @private\n */\nconst lexicons = {};\n\n/**\n * Lexicon class : helpers to store and manage DSL's API.\n * \n * A __Lexicon__ is just an object aimed to handle, store and construct easily a DSL (its lexic - i.e. the bunch of words that compose it)\n * and its related Atomic/FirstLevel/SecondLevel Babelute subclasses, and their initializers.\n *\n * One DSL = One lexicon.\n *\n * A lexicon could extend another lexicon to manage dialects.\n *\n * You should never use frontaly the constructor (aka never use new Lexicon in  your app). Use createLexicon in place.\n * \n * @public\n */\nclass Lexicon {\n\n\t/**\n\t * @param  {string} name   the lexicon name\n\t * @param  {?Lexicon} parent an optional parent lexicon to be extended here\n\t */\n\tconstructor(name, parent = null) {\n\n\t\tassert(typeof name === 'string' && name.length, 'Lexicon constructor need a valid name as first argument'); // all assertions will be removed in production\n\t\tassert(!parent || parent instanceof Lexicon, 'Lexicon constructor second (optional) argument should be another Lexicon that will be used as parent');\n\n\t\t/**\n\t\t * the parent lexicon (if any)\n\t\t * @type {Lexicon}\n\t\t * @public\n\t\t */\n\t\tthis.parent = parent;\n\t\tparent = parent || {};\n\n\t\t/**\n\t\t * the lexicon's name\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t// the three APIs :\n\t\t/**\n\t\t * interpretable sentences API (finally always made from syntactical atoms (aka last level))\n\t\t * @type {Babelute}\n\t\t * @protected\n\t\t */\n\t\tthis.Atomic = initClass(parent.Atomic || Babelute);\n\t\t/**\n\t\t * \"document\" sentences API (first level : aka all methods has been replaced by fake atomic methods)\n\t\t * @type {Babelute}\n\t\t * @protected\n\t\t */\n\t\tthis.FirstLevel = initClass(parent.FirstLevel || FirstLevel);\n\t\t/**\n\t\t * AST-provider API aka the whole tree between first level and last level. Never use it directly : its used under the hood by {@link developOneLevel} method.\n\t\t * @type {Babelute}\n\t\t * @protected\n\t\t */\n\t\tthis.SecondLevel = Babelute.extends(parent.SecondLevel || Babelute);\n\n\t\t/**\n\t\t * the secondLevel instance\n\t\t * @type {Babelute}\n\t\t * @protected\n\t\t */\n\t\tthis.secondLevel = new this.SecondLevel();\n\n\t\tif (parent.Atomic)\n\t\t\tObject.keys(parent.Atomic.initializer)\n\t\t\t.forEach((key) => {\n\t\t\t\taddToInitializer(this.Atomic.Initializer, key);\n\t\t\t\taddToInitializer(this.FirstLevel.Initializer, key);\n\t\t\t});\n\t}\n\n\t/**\n\t * add atomic lexem (atoms) to lexicon\n\t * @param {string[]} atomsArray array of atoms name (as string)\n\t * @return {Lexicon} the lexicon itself\n\t */\n\taddAtoms(atomsArray) {\n\n\t\tassert(Array.isArray(atomsArray), 'lexicon.addAtoms(...) need an array as first argument');\n\n\t\tatomsArray.forEach((name) => addAtom(this, name));\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * add compounds lexems to lexicon\n\t * @param {Function} producer a function that take a babelute initializer as argument and that return an object containing methods (lexems) to add to lexicon\n\t * @return {Lexicon} the lexicon itself\n\t */\n\taddCompounds(producer) {\n\n\t\tassert(typeof producer === 'function', 'lexicon.addCompounds(...) need a function (that return an object containing dsl methods) as first argument');\n\n\t\t// Atomic API is produced with Atomic initializer\n\t\tconst atomicMethods = producer(this.Atomic.initializer);\n\n\t\tassert(atomicMethods && typeof atomicMethods === 'object', 'lexicon.addCompounds(function(){...}) need a function that return an object containing dsl methods to add');\n\n\t\tfor (let i in atomicMethods)\n\t\t\tthis.Atomic.prototype[i] = atomicMethods[i];\n\n\t\t// SecondLevel API is simply produced with the related FirstLevel initializer. \n\t\t// (so same producer method, same api, but different handler for inner composition)\n\t\t// is the only thing to do to gain capability to handle full AST. (see docs)\n\t\tconst secondLevelCompounds = producer(this.FirstLevel.initializer);\n\t\tfor (let j in secondLevelCompounds)\n\t\t\tthis.SecondLevel.prototype[j] = secondLevelCompounds[j];\n\n\t\tObject.keys(atomicMethods)\n\t\t\t.forEach((key) => {\n\t\t\t\tthis.FirstLevel.prototype[key] = FirstLevel.getFirstLevelMethod(this.name, key);\n\t\t\t\taddToInitializer(this.Atomic.Initializer, key);\n\t\t\t\taddToInitializer(this.FirstLevel.Initializer, key);\n\t\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * add aliases lexems to lexicon (aliases are like shortcuts : they are added as this to Atomic, FirstLevel and SecondLevel API)\n\t * @param {Object} methods an object containing methods (lexems) to add to lexicon\n\t * @return {Lexicon} the lexicon itself\n\t */\n\taddAliases(methods){\n\t\tObject.keys(methods)\n\t\t\t.forEach((key) => {\n\t\t\t\tthis.Atomic.prototype[key] = this.FirstLevel.prototype[key] = this.SecondLevel.prototype[key] = methods[key];\n\t\t\t\taddToInitializer(this.Atomic.Initializer, key);\n\t\t\t\taddToInitializer(this.FirstLevel.Initializer, key);\n\t\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * @protected\n\t */\n\tuse(babelute, name, args, firstLevel) {\n\t\tassert(babelute && babelute.__babelute__, 'lexicon.use(...) need a babelute intance as first argument');\n\t\tassert(typeof name === 'string', 'lexicon.use(...) need a string (a method name) as second argument');\n\n\t\tconst instance = firstLevel ? this.FirstLevel.instance : this.Atomic.instance;\n\n\t\tif (!instance[name])\n\t\t\tthrow new Error(`Babelute (${ this.name }) : method not found : ${ name }`);\n\t\tinstance[name].apply(babelute, args);\n\t}\n\n\t/**\n\t * @protected\n\t */\n\ttranslateToAtomic(babelute, targets) {\n\t\treturn translate(babelute, this.Atomic, targets || this.targets);\n\t}\n\n\t/**\n\t * @protected\n\t */\n\ttranslateToFirstLevel(babelute, targets) {\n\t\treturn translate(babelute, this.FirstLevel, targets || this.targets);\n\t}\n\n\t/**\n\t * return lexicon's initializer instance. (atomic or firstlevel depending on argument)\n\t * @public\n\t * @param  {Boolean} firstLevel true if you want firstLevel initializer, false overwise.\n\t * @return {Initializer}           the needed initializer instance\n\t */\n\tinitializer(firstLevel){\n\t\treturn firstLevel ? this.FirstLevel.initializer : this.Atomic.initializer;\n\t}\n}\n\n/**\n *  Add syntactical atom lexem to lexicon (actually to inner classes that reflect API). A syntactical Atom method is a function that only add one lexem.\n *  @private\n */\nfunction addAtom(lexicon, name) {\n\tassert(lexicon instanceof Lexicon, 'Lexicon addAtom(...) first argument should be a Lexicon where add syntactical atom');\n\tassert(typeof name === 'string', 'Lexicon addAtom(...) need a string (a method name) as second argument');\n\n\tlexicon.Atomic.prototype[name] = lexicon.FirstLevel.prototype[name] = lexicon.SecondLevel.prototype[name] = FirstLevel.getFirstLevelMethod(lexicon.name, name);\n\taddToInitializer(lexicon.Atomic.Initializer, name);\n\taddToInitializer(lexicon.FirstLevel.Initializer, name);\n}\n\n/**\n * babelute lexicon's Classes initialisation\n * @private\n */\nfunction initClass(BaseClass) {\n\tconst Class = Babelute.extends(BaseClass);\n\tcreateInitializer(Class, BaseClass.Initializer);\n\tClass.instance = new Class();\n\treturn Class;\n}\n\n/**\n * Way to create lexicon instances\n * @public\n * @param  {string} name   the name of the lexicon\n * @param  {Lexicon} parent a lexicon instance as parent for this one (optional)\n * @return {Lexicon}      a lexicon instance\n */\nfunction createLexicon(name, parent = null) {\n\treturn new Lexicon(name, parent);\n}\n\n/**\n * getLexicon registred lexicon by name\n * \n * @param  {string} lexiconName the lexicon's name\n * @return {Lexicon}      the lexicon\n * @throws {Error} If lexicon not found with lexiconName\n */\nfunction getLexicon(lexiconName) {\n\tassert(typeof lexiconName === 'string', 'Lexicon.getLexicon(...) need a string (a lexicon name) as first argument');\n\n\tconst lexicon = lexicons[lexiconName];\n\tif (!lexicon)\n\t\tthrow new Error('lexicon not found : ' + lexiconName);\n\treturn lexicon;\n}\n\n/**\n * registerLexicon lexicon by name\n * @param  {Lexicon} lexicon the lexicon instance to registerLexicon\n * @param  {?string} name    lexicon name (optional : if not provided : use the one from lexicon itself)\n */\nfunction registerLexicon(lexicon, name = null) {\n\tassert(lexicon instanceof Lexicon, 'Lexicon.registerLexicon(...) first argument should be a Lexicon');\n\tassert(!name || typeof name === 'string', 'Lexicon.registerLexicon(...) need a string (a lexicon name) as second argument');\n\n\tlexicons[name || lexicon.name] = lexicon;\n}\n\n/*\n * _lexicon handeling\n */\n\n// implementation of already declared method in Babelute's proto\nBabelute.prototype._lexicon = function(lexiconName) {\n\tassert(typeof lexiconName === 'string', '._lexicon(...) accept only a string (a Lexicon id) as argument');\n\treturn new(getLexicon(lexiconName).Atomic)(this._lexems);\n};\n\nFirstLevel.prototype._lexicon = function(lexiconName) {\n\tassert(typeof lexiconName === 'string', '._lexicon(...) accept only a string (a Lexicon id) as argument');\n\treturn new(getLexicon(lexiconName).FirstLevel)(this._lexems);\n};\n\n\n/**\n * _use handeling\n */\n\n// implementation of already declared method in Babelute's proto\nBabelute.prototype._use = function(babelute /* could be a string in \"lexiconName:methodName\" format */ , ...args) {\n\tassert(!babelute || typeof babelute === 'string' || babelute.__babelute__);\n\treturn babelute ? use(this, babelute, args, false) : this;\n};\n\n// implementation of already declared method in Babelute's proto\nFirstLevel.prototype._use = function(babelute /* could be a string in \"lexiconName:methodName\" format */ /*, ...args */ ) {\n\tassert(!babelute || typeof babelute === 'string' || babelute.__babelute__);\n\treturn babelute ? use(this, babelute, [].slice.call(arguments, 1), true) : this;\n};\n\nfunction use(self, babelute, args, firstLevel) {\n\tif (typeof babelute === 'string') {\n\t\tconst {\n\t\t\tlexiconName,\n\t\t\tmethodName\n\t\t} = babelute.split(':');\n\t\tgetLexicon(lexiconName).use(self, methodName, args, firstLevel);\n\t} else if (babelute.__babelute__)\n\t\tself._lexems = self._lexems.concat(babelute._lexems);\n\treturn self;\n}\n\n/**\n * Translation\n */\nfunction translate(babelute, BabeluteClass, targets) {\n\tconst b = new BabeluteClass();\n\tbabelute._lexems.forEach(function(lexem) {\n\t\tif ((targets && !targets[lexem.lexicon]) || this[lexem.name]) // simply forwards lexem (copy) if not in targets\n\t\t\tthis._lexems.push(new Lexem(lexem.lexicon, lexem.name, lexem.args));\n\t\telse\n\t\t\tthis[lexem.name].apply(this, lexem.args.map((value) => {\n\t\t\t\tif (!value || !value.__babelute__)\n\t\t\t\t\treturn value;\n\t\t\t\treturn translate(value, BabeluteClass, targets);\n\t\t\t}));\n\t}, b);\n\treturn b;\n}\n\n/**\n * return a new babelute from needed lexicon\n * @param  {string} lexiconName             the lexicon from where to take api\n * @param  {Boolean} asFirstLevel  True if it needs to return a FirstLevel instance. False or ommitted : returns an Atomic instance.\n * @return {[type]}                  the babelute instance (either an Atomic or a FirstLevel)\n * @throws {Error} If lexicon not found with lexiconName\n */\nfunction init(lexiconName, asFirstLevel) {\n\tif (lexiconName)\n\t\treturn new(getLexicon(lexiconName)[asFirstLevel ? 'FirstLevel' : 'Atomic'])();\n\telse if (asFirstLevel)\n\t\treturn new FirstLevel();\n\treturn new Babelute();\n}\n\n/**\n * develop a FirstLevel compounds-words-lexem through SecondLevel API. It returns the FirstLevel sentence corresponding to lexem's semantic developement.\n * @param  {Lexem} lexem the lexem to develop\n * @param {?Lexicon} lexicon the optional lexicon to use\n * @return {FirstLevel} the developed sentence\n * @throws {Error} If lexicon not found with lexem.lexicon\n * @throws {Error} If method not found in lexicon\n */\nfunction developOneLevel(lexem, lexicon = null) {\n\tassert(lexem && lexem.__babelutelexem__, 'lexicon.developOneLevel(...) need a lexem intance as first argument');\n\tassert(lexicon === null || lexicon instanceof Lexicon, 'lexicon.developOneLevel(...) second argument should be null or an instance of Lexicon');\n\n\tlexicon = lexicon || getLexicon(lexem.lexicon);\n\n\tassert(lexicon.secondLevel[lexem.name], 'lexicon.developOneLevel(...) : lexem\\'s name not found in its own referenced lexicon');\n\n\treturn lexicon.secondLevel[lexem.name].apply(new lexicon.FirstLevel(), lexem.args);\n}\n\n/**\n * develop a FirstLevel lexem through Atomic API. Return the atomic representation of the lexem (in its own language).\n * @param  {Lexem} lexem the lexem to develop\n * @param {?Lexicon} lexicon the optional lexicon to use\n * @return {Babelute} the developed sentence\n * @throws {Error} If lexicon not found with lexem.lexicon\n * @throws {Error} If method not found in lexicon\n */\nfunction developToAtoms(lexem, lexicon = null) {\n\tassert(lexem && lexem.__babelutelexem__, 'lexicon.developToAtoms(...) need a lexem intance as first argument');\n\tassert(lexicon === null || lexicon instanceof Lexicon, 'lexicon.developToAtoms(...) second argument should be null or an instance of Lexicon');\n\n\tlexicon = lexicon || getLexicon(lexem.lexicon);\n\n\tassert(lexicon.Atomic.instance[lexem.name], 'lexicon.developToAtoms(...) : lexem\\'s name not found in its own referenced lexicon');\n\n\treturn lexicon.Atomic.prototype[lexem.name].apply(new lexicon.Atomic(), lexem.args);\n}\n\n/**\n * Provide Babelute Subclass \"initializer\" object (the one with all the flattened shortcut api for starting sentences easily)\n * @param  {string} lexiconName The lexiconName where catch the Babelute Class from where getLexicon or create the initializer object.\n * @param  {boolean} asFirstLevel true if should return a first-level instance. false to return an atomic instance.\n * @return {Object}   An initializer object with shortcuted API from lexicon's Atomic prototype\n * @throws {Error} If lexicon not found with lexiconName\n */\nfunction initializer(lexiconName, asFirstLevel) {\n\tassert(typeof lexiconName === 'string', 'Babelute.initializer(...) accept only a string (a Lexicon id) as argument');\n\tif (!asFirstLevel)\n\t\treturn getLexicon(lexiconName).Atomic.initializer;\n\treturn getLexicon(lexiconName).FirstLevel.initializer;\n}\n\nexport {\n\tLexicon,\n\tcreateLexicon,\n\tgetLexicon,\n\tregisterLexicon,\n\tinit,\n\tinitializer,\n\tdevelopOneLevel,\n\tdevelopToAtoms\n};\n\n","/**\n * Pragmatics Class : minimal abstract class for homogeneous pragmatics.\n *\n * This is the minimal contract that a pragmatics should satisfy.\n *\n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2016-2017 Gilles Coomans\n */\n\nimport assert from 'assert'; // removed in production\n\n/**\n * Base class to provide homogeneous Pragmatics interface. You should never instanciate a Pragmatics directly with new. use {@link createPragmatics}.\n */\nexport class Pragmatics {\n\n\t/**\n\t * @param  {Object} targets initial targets object\n\t * @param  {Object} pragmas pragmatics methods to add\n\t */\n\tconstructor(targets = {}, pragmas = {}) {\n\n\t\tassert(typeof targets === 'object', 'Pragmatics constructor need an object (the lexicons targets) as first argument');\n\t\tassert(typeof pragmas === 'object', 'Pragmatics constructor need an object (the pragma\\'s base methods) as second argument');\n\n\t\t/**\n\t\t * targets holder object\n\t\t * @type {Object}\n\t\t * @public\n\t\t */\n\t\tthis._targets = targets;\n\n\t\tif(pragmas)\n\t\t\tthis.addPragmas(pragmas);\n\t}\n\n\t/**\n\t * add methods to pragmatics instance\n\t * @param {Object} pragmas an object containing methods to add\n\t */\n\taddPragmas(pragmas) {\n\n\t\tassert(pragmas && typeof pragmas === 'object', 'pragmatics.addPragmas(...) need a valid object (the methods map to add) as argument');\n\n\t\tfor (const i in pragmas)\n\t\t\t/**\n\t\t\t * @ignore\n\t\t\t */\n\t\t\tthis[i] = pragmas[i];\n\t}\n\n\t/* istanbul ignore next */\n\t/**\n\t * the method used to output a babelute through this pragmatics instance\n\t * @abstract\n\t */\n\t$output( /* ... */ ) {\n\t\t// to be overridden\n\t\tthrow new Error('pragmatics.$output should be implemented in subclasses');\n\t}\n}\n\n/**\n * return a new Pragmatics instance. Do not forget to implement $output before usage.\n * @param  {Object} targets initial targets object\n * @param  {Object} pragmas pragmatics methods to add\n * @return {Pragmatics}   the Pragmatics instance\n */\nexport function createPragmatics(targets = {}, pragmas = {}) {\n\treturn new Pragmatics(targets, pragmas);\n}\n\n","/**\n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2016-2017 Gilles Coomans\n */\n\nimport assert from 'assert'; // removed in production\nimport {\n\tBabelute\n} from '../babelute.js';\nimport { Pragmatics } from './pragmatics-core.js';\n\n/**\n * FacadePragmatics : a facade oriented Pragmatics subclass. You should never instanciate a FacadePragmatics directly with new. use {@link createFacadePragmatics}.\n * @example\n * // Remarque : any lexem's method will be of the following format : \n * function(subject, args, ?percolator){\n * \t// return nothing\n * }\n */\nexport class FacadePragmatics extends Pragmatics {\n\n\t/**\n\t * @param  {Object} targets initial targets object\n\t * @param  {?Object} pragmas pragmatics methods to add\n\t */\n\tconstructor(targets, pragmas = null) {\n\t\tsuper(targets, pragmas);\n\t}\n\n\t/**\n\t * \"each\" facade implementation\n\t * @param  {Object} subject the handled subject\n\t * @param  {Array|arguments} args  the lexem's args : [ collection:Array, itemHandler:Function ]\n\t * @param  {?Object} percolator  the sentence's percolator instance\n\t * @return {void}         nothing\n\t */\n\teach(subject, args /* collection, itemHandler */ , percolator) {\n\n\t\tassert(typeof subject === 'object', '.each facade pragma need an object as subject (first argument)');\n\t\tassert(Array.isArray(args[0]) || args[0].length, '.each facade pragma need an array (or iterable with bracket access) as first args object (first argument passed to lexem)');\n\t\tassert(typeof args[1] === 'function', '.each facade pragma need a function as second args object (second argument passed to lexem)');\n\t\t\n\t\tconst collec = args[0],\n\t\t\titemHandler = args[1];\n\n\t\tif (collec.length) // no supputation on collection kind : use \"for\"\n\t\t\tfor (let i = 0, len = collec.length, item, templ; i < len; ++i) {\n\t\t\t\titem = collec[i];\n\t\t\t\ttempl = itemHandler(item, i);\n\t\t\t\tif (templ)\n\t\t\t\t\tthis.$output(subject, templ, percolator);\n\t\t\t}\n\t}\n\n\t/**\n\t * \"if\" facade implementation \n\t * @param  {Object} subject the handled subject\n\t * @param  {Array|arguments} args  the lexem's args : [ conditionIsTrue:Babelute, conditionIsFalse:Babelute ]\n\t * @param  {?Object} percolator  the sentence's percolator instance\n\t * @return {void}         nothing\n\t */\n\tif (subject, args /* trueBabelute, falseBabelute */ , percolator) {\n\n\t\tassert(typeof subject === 'object', '.if facade pragma need an object as subject (first argument)');\n\t\tassert(args[1] instanceof Babelute, '.if facade pragma need an babelute instance as second args object (second argument passed to lexem)');\n\t\tassert(!args[2] || args[2] instanceof Babelute, '.if facade pragma third args object (third argument passed to lexem) (optional) should be a babelute instance');\n\n\t\tif (args[0])\n\t\t\tthis.$output(subject, args[1], percolator);\n\t\telse if (args[2])\n\t\t\tthis.$output(subject, args[2], percolator);\n\t}\n\n\t/**\n\t *\n\t * @override\n\t * @param  {Object} subject  the subject handle through interpretation\n\t * @param  {Babelute} babelute the babelute \"to interpret on\" subject\n\t * @param  {Scope} percolator   the sentence percolator instance (optional)\n\t * @return {Object}        the subject\n\t */\n\t$output(subject, babelute, percolator = null) {\n\n\t\tassert(typeof subject === 'object', '.$output facade pragma need an object as subject (first argument)');\n\t\tassert(babelute instanceof Babelute, '.$output facade pragma need an babelute instance as second argument');\n\t\tassert(!percolator || typeof percolator === 'object', '.$output facade pragma need an (optional) scope instance as third argument');\n\n\t\tfor (let i = 0, lexem, len = babelute._lexems.length; i < len; ++i) {\n\t\t\tlexem = babelute._lexems[i];\n\t\t\tif (this._targets[lexem.lexicon] && this[lexem.name])\n\t\t\t\tthis[lexem.name](subject, lexem.args, percolator);\n\t\t}\n\t\treturn subject;\n\t}\n}\n\n/**\n * create a facade-ready-to-run initializer function.\n * @param  {Lexicon} lexicon    the lexicon from where take the api\n * @param  {Object} pragmatics   the pragmatics object where to find interpretation method to fire immediatly\n * @return {Function}            the facade initializer function\n * @example\n *\n * import babelute from 'babelute';\n * const myLexicon = babelute.createLexicon('my-lexicon');\n * myLexicon.addAtoms(['foo', 'bar']);\n * \n * const myPragmas = babelute.createFacadePragmatics({\n * \t'my-lexicon':true\n * }, {\n * \tfoo(subject, args, percolator){\n * \t\t// do something\n * \t},\n * \tbar(subject, args, percolator){\n * \t\t// do something\n * \t}\n * });\n *\n * const mlp = babelute.createFacadeInitializer(myLexicon, myPragmas);\n *\n * mlp(mySubject).foo(...).bar(...); // apply pragmas immediatly on subject through lexicon api's\n *\n */\nexport function createFacadeInitializer(lexicon, pragmatics) {\n\tconst Facade = function(subject, percolator = null) {\n\t\tlexicon.Atomic.call(this);\n\t\tthis._subject = subject;\n\t\tthis._percolator = percolator;\n\t};\n\n\tFacade.prototype = Object.create(lexicon.Atomic.prototype);\n\tFacade.prototype.constructor = Facade;\n\tFacade.prototype._lexicon = null;\n\tFacade.prototype._append = function(lexiconName, name, args) {\n\t\tif ((!pragmatics._targets || pragmatics._targets[lexiconName]) && pragmatics[name])\n\t\t\tpragmatics[name](this._subject, args, this._percolator);\n\t\treturn this;\n\t};\n\treturn (subject, percolator = null) => {\n\t\treturn new Facade(subject, percolator);\n\t};\n}\n\n/**\n * create a FacadePragmatics instance\n * @param  {Object} targets the pragmatics targets DSL\n * @param  {?Object} pragmas the methods to add\n * @return {FacadePragmatics}     the facade pragmatics instance\n * @example\n * const myPragmas = babelute.createFacadePragmatics({\n * \t'my-lexicon':true\n * }, {\n * \tfoo(subject, args, percolator){\n * \t\t// do something\n * \t},\n * \tbar(subject, args, percolator){\n * \t\t// do something\n * \t}\n * });\n */\nexport function createFacadePragmatics(targets, pragmas = null) {\n\treturn new FacadePragmatics(targets, pragmas);\n}\n\n","/*\n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2016 Gilles Coomans\n */\n\n// core classes and functions\nimport {\n\tBabelute,\n\tLexem,\n\tfromJSON\n} from './babelute.js';\nimport {\n\tcreateLexicon,\n\tinit,\n\tgetLexicon,\n\tregisterLexicon,\n\tinitializer,\n\tdevelopOneLevel,\n\tdevelopToAtoms\n} from './lexicon/lexicon.js';\nimport { Pragmatics, createPragmatics } from './pragmatics/pragmatics-core.js';\nimport { FacadePragmatics, createFacadeInitializer, createFacadePragmatics } from './pragmatics/facade-pragmatics.js';\n// import Scopes from './pragmatics/pragmatics-scopes.js';\n\nexport default {\n\tcreateLexicon,\n\tcreatePragmatics,\n\tcreateFacadeInitializer,\n\tcreateFacadePragmatics,\n\tinit,\n\tinitializer,\n\tgetLexicon,\n\tregisterLexicon,\n\tdevelopOneLevel,\n\tdevelopToAtoms,\n\tfromJSON,\n\tBabelute,\n\tLexem,\n\tPragmatics,\n\tFacadePragmatics\n\t// Scopes\n};\n\n","/**\n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2016 Gilles Coomans\n */\n\n/********************************************************************\n ********************************************************************\n * Stringify Babelute to serialised form (beautified or minified)\n ********************************************************************\n ********************************************************************/\n\n// utils\nfunction pushLexicScope(opt, lexicon, alreadyPushed) {\n\tif (alreadyPushed)\n\t\topt.lexicScope[opt.lexicScope.length - 1] = lexicon;\n\telse\n\t\topt.lexicScope.push(lexicon);\n\topt.currentLexic = lexicon;\n\treturn true;\n}\n\nfunction popLexicScope(opt) {\n\topt.lexicScope.pop();\n\topt.currentLexic = opt.lexicScope[opt.lexicScope.length - 1];\n}\n\nfunction removeLastUndefined(arr) {\n\tconst len = arr.length;\n\tlet index = len;\n\twhile (index && arr[index - 1] === undefined)\n\t\tindex--;\n\tif (index < len)\n\t\tarr.splice(index, len - index);\n\treturn arr;\n}\n\n/********************************************************************\n ********** beautyfy\n ********************************************************************/\n\nfunction beautyLexems(lexems, opt) {\n\tconst lexemsOutput = [];\n\tlet outlength = 0,\n\t\titem,\n\t\targs,\n\t\tlexicPushed = false,\n\t\tout;\n\tfor (let i = 0, len = lexems.length; i < len; ++i) {\n\t\titem = lexems[i];\n\t\tif (item.lexicon !== opt.currentLexic) {\n\t\t\tout = '#' + item.lexicon + ':';\n\t\t\tlexemsOutput.push(out);\n\t\t\tlexicPushed = pushLexicScope(opt, item.lexicon, lexicPushed);\n\t\t}\n\t\tif (item.args) {\n\t\t\targs = beautyArrayValues(removeLastUndefined(item.args), opt);\n\t\t\tif ((item.args.length > 1 || (item.args[0] && item.args[0].__babelute__)) && args.length > opt.maxLength) // add EOL\n\t\t\t\tout = item.name + '(\\n\\t' + args.replace(/\\n/g, (s) => {\n\t\t\t\t\treturn s + '\\t';\n\t\t\t\t}) + '\\n)';\n\t\t\telse\n\t\t\t\tout = item.name + '(' + args + ')';\n\t\t} else\n\t\t\tout = item.name + '()';\n\n\t\tlexemsOutput.push(out);\n\t\toutlength += out.length;\n\t}\n\tif (lexicPushed)\n\t\tpopLexicScope(opt);\n\toutlength += lexems.length - 1;\n\treturn lexemsOutput.join((outlength > opt.maxLength) ? '\\n' : ' ');\n}\n\nfunction beautyArray(arr, opt) {\n\tconst len = arr.length;\n\tif (!len)\n\t\treturn '[]';\n\tconst out = beautyArrayValues(arr, opt),\n\t\taddReturn = (len > 1 && out.length > opt.maxLength);\n\tif (addReturn)\n\t\treturn '[\\n\\t' + out.replace(/\\n/g, (s) => {\n\t\t\treturn s + '\\t';\n\t\t}) + '\\n]';\n\treturn '[' + out + ']';\n}\n\nfunction beautyArrayValues(arr, opt) {\n\tconst len = arr.length;\n\tif (!len)\n\t\treturn '';\n\tconst values = [];\n\tlet out,\n\t\toutlength = 0;\n\tfor (let i = 0; i < len; ++i) {\n\t\tout = valueToString(arr[i], opt);\n\t\tvalues.push(out);\n\t\toutlength += out.length;\n\t}\n\toutlength += len - 1;\n\treturn values.join((outlength > opt.maxLength) ? ',\\n' : ', ');\n}\n\nfunction beautyObject(obj, opt) {\n\tconst keys = Object.keys(obj);\n\tconst out = beautyProperties(obj, keys, opt);\n\tif (keys.length > 1 && out.length > opt.maxLength) { // add returns\n\t\treturn '{\\n\\t' + out.replace(/\\n/g, (s) => {\n\t\t\treturn s + '\\t';\n\t\t}) + '\\n}';\n\t}\n\treturn '{ ' + out + ' }';\n}\n\nfunction beautyProperties(obj, keys, opt) {\n\tconst values = [];\n\tlet out,\n\t\toutlength = 0,\n\t\tkey;\n\tfor (let i = 0, len = keys.length; i < len; ++i) {\n\t\tkey = keys[i];\n\t\tout = valueToString(obj[key], opt);\n\t\toutlength += out.length;\n\t\tvalues.push(key + ': ' + out);\n\t}\n\toutlength += keys.length - 1;\n\treturn (outlength > opt.maxLength) ? values.join(',\\n') : values.join(', ');\n}\n\n\n/********************************************************************\n ********** minify\n ********************************************************************/\n\nfunction valueToString(val, opt) {\n\tif (!val)\n\t\treturn val + '';\n\tlet out;\n\tswitch (typeof val) {\n\t\tcase 'object':\n\t\t\tif (val.__babelute__)\n\t\t\t\treturn toUUS(val, opt);\n\t\t\tif (val.forEach)\n\t\t\t\treturn (opt.beautify) ? beautyArray(val, opt) : '[' + arrayToString(val, opt) + ']';\n\t\t\treturn (opt.beautify) ? beautyObject(val, opt) : objectToString(val, opt);\n\t\tcase 'string':\n\t\t\t// return '\"' + val.replace(/\"/g, '\\\\\"') + '\"'; // adds quotes and escapes content\n\t\t\treturn JSON.stringify(val); // adds quotes and escapes content\n\t\tcase 'function':\n\t\t\tout = (val + '').replace(/anonymous/, '').replace(/\\n\\/\\*\\*\\//, '');\n\t\t\treturn opt.beautify ? out : out.replace(/`[^`]*`|\\n\\s*/g, (val) => {\n\t\t\t\treturn val[0] === \"`\" ? val : ' ';\n\t\t\t});\n\t\tdefault:\n\t\t\treturn val + '';\n\t}\n}\n\nfunction arrayToString(arr, opt) {\n\tif (!arr.length)\n\t\treturn '';\n\t// map output\n\tlet out = '';\n\tfor (let i = 0, len = arr.length; i < len; ++i)\n\t\tout += (i ? ',' : '') + valueToString(arr[i], opt);\n\treturn out;\n}\n\nfunction objectToString(obj, opt) {\n\tconst keys = Object.keys(obj);\n\tlet out = '';\n\tfor (let i = 0, len = keys.length, key; i < len; ++i) {\n\t\tkey = keys[i];\n\t\tout += (i ? ',' : '') + key + ':' + valueToString(obj[key], opt);\n\t}\n\treturn '{' + out + '}';\n}\n\n/********************************************************************\n ********** end minify\n ********************************************************************/\n\n/**\n * Stringify a babelute instance to UUS\n * @param  {Babelute} babelute the babelute instance to serialize\n * @param  {Object={}} opt      options\n * @return {string}          the resulting UUS string\n * @todo  manage options.pragmatics map for custom output\n */\nfunction toUUS(babelute, opt = {}) {\n\n\topt.lexicScope = opt.lexicScope || [];\n\n\tif (opt.beautify) {\n\t\topt.maxLength = opt.maxLength || 20;\n\t\treturn beautyLexems(babelute._lexems, opt);\n\t}\n\n\t// else minifiy lexems\n\tconst lexems = babelute._lexems;\n\tlet\tout = '',\n\t\titem,\n\t\tlexicPushed = false;\n\tfor (let i = 0, len = lexems.length; i < len; ++i) {\n\t\titem = lexems[i];\n\t\tif (item.lexicon !== opt.currentLexic) {\n\t\t\tout += '#' + item.lexicon + ':';\n\t\t\tlexicPushed = pushLexicScope(opt, item.lexicon, lexicPushed);\n\t\t}\n\t\tout += item.name + '(' + (item.args ? arrayToString(removeLastUndefined(item.args), opt) : '') + ')';\n\t}\n\n\tif (lexicPushed)\n\t\tpopLexicScope(opt);\n\n\treturn out;\n}\n\nexport default toUUS;\n\n","var classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n/*\n* @Author: Gilles Coomans\n* @Last Modified by:   Gilles Coomans\n* @Last Modified time: 2017-03-17 15:20:54\n*/\n\n/**\n * The Parser class.\n * @public\n */\nvar Parser = function () {\n\n\t/**\n  * @param  {Object} rules       an object containing rules\n  * @param  {String} defaultRule the default rule to use when parsing\n  */\n\tfunction Parser(rules, defaultRule) {\n\t\tclassCallCheck(this, Parser);\n\n\n\t\t/**\n   * the rules map\n   * @type {Object}\n   */\n\t\tthis.rules = rules;\n\n\t\t/**\n   * the default rule's name to use\n   * @type {String}\n   */\n\t\tthis.defaultRule = defaultRule;\n\t}\n\n\t/**\n  * find rule by name\n  * @param  {String} name the rule's name\n  * @return {Rule}      the finded rule\n  * @throws {Error} If rule not found\n  */\n\n\n\tcreateClass(Parser, [{\n\t\tkey: 'getRule',\n\t\tvalue: function getRule(name) {\n\t\t\tvar r = this.rules[name];\n\t\t\tif (!r) throw new Error('elenpi parser : rules not found : ' + name);\n\t\t\treturn r;\n\t\t}\n\n\t\t/**\n   * Parse provided string with specific rule\n   * @param  {String} string     the string to parse\n   * @param  {String} rule       the name of the rule to apply. default is null (will use parser's default method if not provided).\n   * @param  {Object} descriptor the main descriptor object\n   * @return {Object}            the decorated descriptor\n   * @throws {Error} If parsing fail (for any reason)\n   */\n\n\t}, {\n\t\tkey: 'parse',\n\t\tvalue: function parse(string) {\n\t\t\tvar rule = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\t\tvar descriptor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\t\tvar env = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n\t\t\tenv = env || {};\n\t\t\tenv.parser = this;\n\t\t\tenv.string = string;\n\t\t\trule = rule || this.getRule(this.defaultRule);\n\t\t\tParser.exec(rule, descriptor, env);\n\t\t\tif (!env.error && env.string.length) {\n\t\t\t\tenv.error = true;\n\t\t\t\tenv.errorMessage = 'string wasn\\'t parsed entierly';\n\t\t\t}\n\t\t\tif (env.error) {\n\t\t\t\tvar pos = string.length - env.string.length,\n\t\t\t\t    posInFile = getPositionInFile(string, pos);\n\t\t\t\tthrow new Error('Parsing failed : ' + (env.errorMessage || 'no rules matched') + ' : (line:' + posInFile.line + ' , col:' + posInFile.col + ') near :\\n', string.substring(pos, pos + 50));\n\t\t\t}\n\t\t\treturn descriptor;\n\t\t}\n\n\t\t/**\n   * Execute a rule (only for those who developing grammars)\n   * @param  {String|Rule} rule      the name of the rule to use or the rule itself\n   * @param  {Object} descriptor the descriptor to decorate\n   * @param  {Object} env        the inner-job main object where parser, parsed string and eventual errors are stored\n   * @return {Void}            nothing\n   * @public\n   * @throws {Error} If rule is string (so it's a rule's name) and referenced rule could not be found with it.\n   */\n\n\t}], [{\n\t\tkey: 'exec',\n\t\tvalue: function exec(rule, descriptor, env) {\n\t\t\tif (env.error) return;\n\t\t\tif (typeof rule === 'string') rule = env.parser.getRule(rule);\n\n\t\t\tvar rules = rule._queue;\n\t\t\tfor (var i = 0, current, len = rules.length; i < len; ++i) {\n\t\t\t\tcurrent = rules[i];\n\t\t\t\tif (current.__elenpi__) Parser.exec(current, descriptor, env);else // is function\n\t\t\t\t\tcurrent(env, descriptor);\n\t\t\t\tif (env.error) break;\n\t\t\t}\n\t\t}\n\t}]);\n\treturn Parser;\n}();\n\nfunction getPositionInFile(string, position) {\n\tvar splitted = string.split(/\\r|\\n/),\n\t    len = splitted.length;\n\tvar lineNumber = 0,\n\t    current = 0,\n\t    line = void 0,\n\t    lineLength = void 0;\n\twhile (lineNumber < len) {\n\t\tline = splitted[lineNumber];\n\t\tlineLength = line.length;\n\t\tif (position <= current + lineLength) break;\n\t\tcurrent += lineLength;\n\t\tlineNumber++;\n\t}\n\treturn {\n\t\tline: lineNumber + 1,\n\t\tcol: position - current\n\t};\n}\n\n/*\n * @Author: Gilles Coomans\n */\n\nvar defaultSpaceRegExp = /^\\s+/;\nvar exec = Parser.exec;\n\n/**\n * The Rule base class.\n * @public\n */\n\nvar Rule = function () {\n\n\t/**\n  * the Rule constructor\n  */\n\tfunction Rule() {\n\t\tclassCallCheck(this, Rule);\n\n\t\tthis._queue = [];\n\t\tthis.__elenpi__ = true;\n\t}\n\n\t/**\n  * the base handler for every other lexems\n  * @param  {Function} callback the callback to handle string\n  * @return {Rule}          this rule handler\n  */\n\n\n\tcreateClass(Rule, [{\n\t\tkey: 'done',\n\t\tvalue: function done(callback) {\n\t\t\tthis._queue.push(callback);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n   * use another rule  \n   * @param  {String|Rule} rule the rule to use\n   * @return {Rule}          this rule handler\n   */\n\n\t}, {\n\t\tkey: 'use',\n\t\tvalue: function use(rule) {\n\t\t\tvar args = [].slice.call(arguments, 1);\n\t\t\treturn this.done(function (env, descriptor) {\n\t\t\t\tif (typeof rule === 'string') rule = env.parser.getRule(rule);\n\t\t\t\tif (rule.__elenpi__) {\n\t\t\t\t\texec(rule, descriptor, env);\n\t\t\t\t} else {\n\t\t\t\t\tvar _r = new Rule();\n\t\t\t\t\trule.apply(_r, args);\n\t\t\t\t\texec(_r, descriptor, env);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * catch a terminal\n   * @param  {RegExp} reg the terminal's regexp\n   * @param  {String|Function} set either the name of the property (in current descriptor) where store the catched value \n   *                           or a function to handle captured object by hand \n   * @return {Rule}          this rule handler\n   */\n\n\t}, {\n\t\tkey: 'terminal',\n\t\tvalue: function terminal(reg, set$$1) {\n\t\t\treturn this.done(function (env, descriptor) {\n\t\t\t\tif (!env.string.length) {\n\t\t\t\t\tenv.error = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar cap = reg.exec(env.string);\n\t\t\t\tif (cap) {\n\t\t\t\t\tenv.string = env.string.substring(cap[0].length);\n\t\t\t\t\tif (set$$1) {\n\t\t\t\t\t\tif (typeof set$$1 === 'string') descriptor[set$$1] = cap[0];else set$$1(env, descriptor, cap);\n\t\t\t\t\t}\n\t\t\t\t} else env.error = true;\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * match a single character\n   * @param  {String} test the caracter to match\n   * @return {Rule}          this rule handler\n   */\n\n\t}, {\n\t\tkey: 'char',\n\t\tvalue: function char(test) {\n\t\t\treturn this.done(function (env) {\n\t\t\t\tif (!env.string.length || env.string[0] !== test) env.error = true;else env.string = env.string.substring(1);\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * match x or more element from string with provided rule\n   * @param  {Rule|Object} rule either a rule instance or an option object\n   * @return {Rule}          this rule handler\n   */\n\n\t}, {\n\t\tkey: 'xOrMore',\n\t\tvalue: function xOrMore(rule) {\n\t\t\tvar opt = typeof rule === 'string' || rule.__elenpi__ ? {\n\t\t\t\trule: rule\n\t\t\t} : rule;\n\t\t\topt.minimum = opt.minimum || 0;\n\t\t\topt.maximum = opt.maximum || Infinity;\n\t\t\treturn this.done(function (env, descriptor) {\n\n\t\t\t\tif (opt.minimum && !env.string.length) {\n\t\t\t\t\tenv.error = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar rule = opt.rule,\n\t\t\t\t    pushTo = opt.pushTo,\n\t\t\t\t    pushToString = typeof pushTo === 'string',\n\t\t\t\t    As = opt.as,\n\t\t\t\t    separator = opt.separator;\n\n\t\t\t\tvar count = 0,\n\t\t\t\t    currentPosition = void 0,\n\t\t\t\t    newDescriptor = void 0,\n\t\t\t\t    restLength = void 0;\n\n\t\t\t\twhile (env.string.length && count < opt.maximum) {\n\n\t\t\t\t\tnewDescriptor = As ? As(env, descriptor) : pushTo ? {} : descriptor;\n\t\t\t\t\tcurrentPosition = env.string.length;\n\n\t\t\t\t\texec(rule, newDescriptor, env);\n\n\t\t\t\t\trestLength = env.string.length;\n\n\t\t\t\t\tif (env.error) {\n\t\t\t\t\t\tif (currentPosition === restLength) // has not moved deeper : so try next rule\n\t\t\t\t\t\t\tenv.error = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\t// store new descriptor in parent descriptor\n\t\t\t\t\tif (!newDescriptor.skip && pushTo) if (pushToString) {\n\t\t\t\t\t\tdescriptor[pushTo] = descriptor[pushTo] || [];\n\t\t\t\t\t\tdescriptor[pushTo].push(newDescriptor);\n\t\t\t\t\t} else pushTo(env, descriptor, newDescriptor);\n\n\t\t\t\t\t// manage separator\n\t\t\t\t\tif (separator && restLength) {\n\t\t\t\t\t\tcurrentPosition = restLength;\n\t\t\t\t\t\texec(separator, newDescriptor, env);\n\t\t\t\t\t\tif (env.error) {\n\t\t\t\t\t\t\tif (currentPosition === env.string.length) env.error = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!env.error && count < opt.minimum) {\n\t\t\t\t\tenv.error = true;\n\t\t\t\t\tenv.errorMessage = \"missing xOrMore item : \" + rule;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * match 0 or more element from string with provided rule\n   * @param  {Rule|Object} rule either a rule instance or an option object\n   * @return {Rule}          this rule handler\n   */\n\n\t}, {\n\t\tkey: 'zeroOrMore',\n\t\tvalue: function zeroOrMore(rule) {\n\t\t\treturn this.xOrMore(rule);\n\t\t}\n\n\t\t/**\n   * match 1 or more element from string with provided rule\n   * @param  {Rule|Object} rule either a rule instance or an option object\n   * @return {Rule}          this rule handler\n   */\n\n\t}, {\n\t\tkey: 'oneOrMore',\n\t\tvalue: function oneOrMore(rule) {\n\t\t\tif (typeof rule === 'string' || rule.__elenpi__) rule = {\n\t\t\t\trule: rule,\n\t\t\t\tminimum: 1\n\t\t\t};else rule.minimum = 1;\n\t\t\treturn this.xOrMore(rule);\n\t\t}\n\n\t\t/**\n   * match one element from string with one of provided rules\n   * @param  {Rule|Object} rules either a rule instance or an option object\n   * @return {Rule}          this rule handler\n   */\n\n\t}, {\n\t\tkey: 'oneOf',\n\t\tvalue: function oneOf(rules) {\n\t\t\tvar opt = typeof rules === 'string' || rules.__elenpi__ ? {\n\t\t\t\trules: [].slice.call(arguments)\n\t\t\t} : rules;\n\t\t\treturn this.done(function (env, descriptor) {\n\n\t\t\t\tif (!opt.optional && !env.string.length) {\n\t\t\t\t\tenv.error = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar len = opt.rules.length,\n\t\t\t\t    currentPosition = env.string.length;\n\n\t\t\t\tvar count = 0,\n\t\t\t\t    rule = void 0,\n\t\t\t\t    newDescriptor = void 0;\n\n\t\t\t\twhile (count < len) {\n\t\t\t\t\trule = opt.rules[count++];\n\t\t\t\t\tnewDescriptor = opt.as ? opt.as(env, descriptor) : opt.set ? {} : descriptor;\n\t\t\t\t\texec(rule, newDescriptor, env);\n\t\t\t\t\tif (env.error) {\n\t\t\t\t\t\tif (env.string.length === currentPosition) {\n\t\t\t\t\t\t\tenv.error = false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else setDescriptor(descriptor, newDescriptor, opt.set, env);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!opt.optional) env.error = true;\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * maybe match one element from string with one of provided rules\n   * @param  {Rule|Object} rules either a rule instance or an option object\n   * @return {Rule}          this rule handler\n   */\n\n\t}, {\n\t\tkey: 'maybeOneOf',\n\t\tvalue: function maybeOneOf(rules) {\n\t\t\tvar opt = typeof rules === 'string' || rules.__elenpi__ ? {\n\t\t\t\trules: [].slice.call(arguments)\n\t\t\t} : rules;\n\t\t\topt.optional = true;\n\t\t\treturn this.oneOf(opt);\n\t\t}\n\n\t\t/**\n   * match one element from string with provided rule\n   * @param  {Rule|Object} rule either a rule instance or an option object\n   * @return {Rule}          this rule handler\n   */\n\n\t}, {\n\t\tkey: 'one',\n\t\tvalue: function one(rule) {\n\t\t\tvar opt = typeof rule === 'string' || rule && rule.__elenpi__ ? {\n\t\t\t\trule: rule\n\t\t\t} : rule;\n\t\t\treturn this.done(function (env, descriptor) {\n\t\t\t\tif (!opt.optional && !env.string.length) {\n\t\t\t\t\tenv.error = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar newDescriptor = opt.as ? opt.as(env, descriptor) : opt.set ? {} : descriptor,\n\t\t\t\t    currentPosition = env.string.length;\n\n\t\t\t\texec(opt.rule, newDescriptor, env);\n\t\t\t\tif (!env.error) setDescriptor(descriptor, newDescriptor, opt.set, env);else if (opt.optional && env.string.length === currentPosition) env.error = false;\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * maybe match one element from string with provided rule\n   * @param  {Rule|Object} rule either a rule instance or an option object\n   * @return {Rule}          this rule handler\n   */\n\n\t}, {\n\t\tkey: 'maybeOne',\n\t\tvalue: function maybeOne(rule) {\n\t\t\tvar opt = typeof rule === 'string' || rule && rule.__elenpi__ ? {\n\t\t\t\trule: rule\n\t\t\t} : rule;\n\t\t\topt.optional = true;\n\t\t\treturn this.one(opt);\n\t\t}\n\n\t\t/**\n   * skip current descriptor\n   * @return {Rule}          this rule handler\n   */\n\n\t}, {\n\t\tkey: 'skip',\n\t\tvalue: function skip() {\n\t\t\treturn this.done(function (env, descriptor) {\n\t\t\t\tdescriptor.skip = true;\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * match a space (any spaces, or carriage returns, or new lines)\n   * @param  {Boolean} needed true if space is needed. false otherwise.\n   * @return {Rule}          this rule handler\n   */\n\n\t}, {\n\t\tkey: 'space',\n\t\tvalue: function space() {\n\t\t\tvar needed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\treturn this.done(function (env) {\n\t\t\t\tif (!env.string.length) {\n\t\t\t\t\tif (needed) env.error = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar cap = (env.parser.rules.space || defaultSpaceRegExp).exec(env.string);\n\t\t\t\tif (cap) env.string = env.string.substring(cap[0].length);else if (needed) env.error = true;\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * match the end of string\n   * @return {Rule}          this rule handler\n   */\n\n\t}, {\n\t\tkey: 'end',\n\t\tvalue: function end() {\n\t\t\treturn this.done(function (env) {\n\t\t\t\tif (env.string.length) env.error = true;\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * force end parsing with error. Only aimed to be used in .oneOf().\n   * @param  {String} msg the error message.\n   * @return {Rule}          this rule handler\n   */\n\n\t}, {\n\t\tkey: 'error',\n\t\tvalue: function error(msg) {\n\t\t\treturn this.done(function (env) {\n\t\t\t\tenv.error = true;\n\t\t\t\tenv.errorMessage = msg;\n\t\t\t});\n\t\t}\n\t}]);\n\treturn Rule;\n}();\n\nfunction setDescriptor(descriptor, newDescriptor, set$$1, env) {\n\tif (!newDescriptor.skip && set$$1) if (typeof set$$1 === 'string') descriptor[set$$1] = newDescriptor;else set$$1(env, descriptor, newDescriptor);\n}\n\nvar r = {};\n\nObject.getOwnPropertyNames(Rule.prototype) // because Babel make prototype methods not enumerable\n.forEach(function (key) {\n\tif (typeof Rule.prototype[key] === 'function') r[key] = function () {\n\t\tvar rule = new Rule();\n\t\treturn rule[key].apply(rule, arguments);\n\t};\n});\n\n/**\n * Rule initializer object (all the Rul's API for starting rule's sentences)\n * @type {Object}\n * @public\n * @static\n */\nRule.initializer = r;\n\n/**\n * elenpi\n * @author Gilles Coomans\n */\n\n/**\n * elenpi export object { Rule, Parser }\n * @type {Object}\n * @public\n */\nvar elenpi = {\n  Rule: Rule,\n  Parser: Parser\n};\n\nexport default elenpi;\n//# sourceMappingURL=index.mjs.map\n","/**\n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2016 Gilles Coomans\n */\n\nimport elenpi from 'elenpi';\nimport babelute from 'babelute/src/index.js';\n\nconst Parser = elenpi.Parser,\n\tr = elenpi.Rule.initializer,\n\tb = babelute.init,\n\treplaceSingleString = /\\\\'/g,\n\treplaceDoubleString = /\\\\\"/g,\n\t// grammar shortcut map (1 char previsu) for values\n\tvaluePrevisuMap = {\n\t\t1: 'number',\n\t\t2: 'number',\n\t\t3: 'number',\n\t\t4: 'number',\n\t\t5: 'number',\n\t\t6: 'number',\n\t\t7: 'number',\n\t\t8: 'number',\n\t\t9: 'number',\n\t\t0: 'number',\n\t\t\"'\": 'singlestring',\n\t\t'\"': 'doublestring',\n\t\t'{': 'object',\n\t\t'[': 'array'\n\t},\n\trules = {\n\t\t//_____________________________________\n\t\tbabelute: r\n\t\t\t.space()\n\t\t\t.oneOrMore({\n\t\t\t\trule: 'lexem',\n\t\t\t\tseparator: r.terminal(/^\\s*/),\n\t\t\t\tpushTo(env, parent, obj) {\n\t\t\t\t\t// Parser.counts.countLexem++;\n\t\t\t\t\tif (obj.lexicon && obj.lexicon !== env.currentLexicon) { // 'scoped' lexicon management\n\t\t\t\t\t\tif (parent.__swapped__) // we have already push something before (aka second (or more) lexicon change on same babelute)\n\t\t\t\t\t\t\tenv.lexicons[env.lexicons.length - 1] = obj.lexicon;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tenv.lexicons.push(obj.lexicon); // push lexicon to scope\n\t\t\t\t\t\tenv.currentLexicon = obj.lexicon;\n\t\t\t\t\t\tconst newParent = b(obj.lexicon, env.asFirstLevel);\n\t\t\t\t\t\tnewParent._lexems = parent._lexems;\n\t\t\t\t\t\tparent.__swapped__ = newParent;\n\t\t\t\t\t} else { // use current babelute lexicon\n\t\t\t\t\t\tparent = parent.__swapped__ || parent;\n\t\t\t\t\t\tgetMethod(parent, obj.name).apply(parent, obj.args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.done((env, babelute) => {\n\t\t\t\tif (babelute.__swapped__) {\n\t\t\t\t\t// 'scoped' lexicon management :\n\t\t\t\t\t// one lexicon has been pushed from this babelute\n\t\t\t\t\t// so pop to parent lexicon\n\t\t\t\t\tenv.lexicons.pop();\n\t\t\t\t\tenv.currentLexicon = env.lexicons[env.lexicons.length - 1];\n\t\t\t\t\tdelete babelute.__swapped__;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.space(),\n\n\t\tlexem: r.oneOf(\n\t\t\t// lexem (aka: name(arg1, arg2, ...))\n\t\t\tr.terminal(/^([\\w-_]+)\\s*\\(\\s*/, (env, obj, cap) => { // lexem name + ' ( '\n\t\t\t\tobj.name = cap[1];\n\t\t\t\tobj.args = [];\n\t\t\t})\n\t\t\t.oneOf(\n\t\t\t\tr.terminal(/^\\s*\\)/), // end parenthesis\n\n\t\t\t\tr.oneOrMore({ // arguments\n\t\t\t\t\trule: 'value',\n\t\t\t\t\tseparator: r.terminal(/^\\s*,\\s*/),\n\t\t\t\t\tpushTo(env, parent, obj) {\n\t\t\t\t\t\t// Parser.counts.countLexemValues++;\n\t\t\t\t\t\tparent.args.push(obj.value);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.terminal(/^\\s*\\)/) // end parenthesis\n\t\t\t),\n\n\t\t\t// lexicon selector (aka #lexicon:)\n\t\t\tr.terminal(/^#([\\w-_]+):/, (env, obj, cap) => { // '@' + lexicon name + ':'\n\t\t\t\tobj.lexicon = cap[1];\n\t\t\t})\n\t\t),\n\n\n\t\t/***********\n\t\t * VALUES\n\t\t ***********/\n\t\tvalue: r\n\t\t\t.done((env, obj) => {\n\t\t\t\tif (!env.string.length) {\n\t\t\t\t\tenv.error = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// shortcut with first char previsu through valueMap\n\t\t\t\tParser.exec(valuePrevisuMap[env.string[0]] || 'wordValue', obj, env);\n\t\t\t}),\n\n\t\tnumber: r.terminal(/^[0-9]+(\\.[0-9]+)?/, (env, obj, cap) => {\n\t\t\tobj.value = cap[1] ? parseFloat(cap[0] + cap[1], 10) : parseInt(cap[0], 10);\n\t\t}),\n\t\tsinglestring: r.terminal(/^'((?:\\\\'|[^'])*)'/, (env, obj, cap) => {\n\t\t\tobj.value = cap[1].replace(replaceSingleString, \"'\");\n\t\t}),\n\t\tdoublestring: r.terminal(/^\"((?:\\\\\"|[^\"])*)\"/, (env, obj, cap) => {\n\t\t\tobj.value = cap[1].replace(replaceDoubleString, '\"');\n\t\t}),\n\n\t\twordValue: r\n\t\t\t.oneOf(\n\t\t\t\t// true|false|null|undefined|NaN|Infinity\n\t\t\t\tr.terminal(/^(?:true|false|null|undefined|NaN|Infinity)/, (env, obj, cap) => {\n\t\t\t\t\tswitch (cap[0]) {\n\t\t\t\t\t\tcase 'true':\n\t\t\t\t\t\t\tobj.value = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'false':\n\t\t\t\t\t\t\tobj.value = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'null':\n\t\t\t\t\t\t\tobj.value = null;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'undefined':\n\t\t\t\t\t\t\tobj.value = undefined;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'NaN':\n\t\t\t\t\t\t\tobj.value = NaN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Infinity':\n\t\t\t\t\t\t\tobj.value = Infinity;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t\t// function\n\t\t\t\tr.one({\n\t\t\t\t\trule: 'function',\n\t\t\t\t\t// previsu: 'f',\n\t\t\t\t\tset(env, parent, obj) {\n\t\t\t\t\t\tif (env.acceptFunctions) // todo : add warning when not allowed but present\n\t\t\t\t\t\t\tparent.value = Function.apply(null, obj.args.concat(obj.block));\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t\t// babelutes\n\t\t\t\tr.one({\n\t\t\t\t\trule: 'babelute',\n\t\t\t\t\tas(env) {\n\t\t\t\t\t\treturn b(env.currentLexicon, env.asFirstLevel);\n\t\t\t\t\t},\n\t\t\t\t\tset(env, parent, obj) {\n\t\t\t\t\t\tparent.value = obj;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t),\n\n\t\tobject: r.one({\n\t\t\trule: r\n\t\t\t\t.terminal(/^\\{\\s*/) // start bracket\n\t\t\t\t.zeroOrMore({ // properties\n\t\t\t\t\trule: r\n\t\t\t\t\t\t// key\n\t\t\t\t\t\t.terminal(/^([\\w-_]+)|\"([^\"]*)\"|'([^']*)'/, (env, obj, cap) => {\n\t\t\t\t\t\t\tobj.key = cap[1];\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.terminal(/^\\s*:\\s*/)\n\t\t\t\t\t\t// value\n\t\t\t\t\t\t.one('value'),\n\t\t\t\t\tseparator: r.terminal(/^\\s*,\\s*/),\n\t\t\t\t\tpushTo(env, parent, obj) {\n\t\t\t\t\t\tparent[obj.key] = obj.value;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.terminal(/^\\s*\\}/), // end bracket\n\n\t\t\tset(env, parent, obj) {\n\t\t\t\tparent.value = obj;\n\t\t\t}\n\t\t}),\n\n\t\tarray: r.one({\n\t\t\trule: r.terminal(/^\\[\\s*/) // start square bracket\n\t\t\t\t.zeroOrMore({ // items\n\t\t\t\t\trule: 'value',\n\t\t\t\t\tseparator: r.terminal(/^\\s*,\\s*/),\n\t\t\t\t\tpushTo(env, parent, obj) {\n\t\t\t\t\t\tparent.push(obj.value);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.terminal(/^\\s*\\]/), // end square bracket\n\n\t\t\tas() {\n\t\t\t\treturn [];\n\t\t\t},\n\t\t\tset(env, parent, obj) {\n\t\t\t\tparent.value = obj;\n\t\t\t}\n\t\t}),\n\n\t\tfunction: r\n\t\t\t.terminal(/^function\\s*\\(\\s*/, (env, obj) => {\n\t\t\t\tobj.args = [];\n\t\t\t\tobj.block = '';\n\t\t\t})\n\t\t\t.zeroOrMore({ // arguments key\n\t\t\t\trule: r.terminal(/^[\\w-_]+/, 'key'),\n\t\t\t\tseparator: r.terminal(/^\\s*,\\s*/),\n\t\t\t\tpushTo(env, parent, obj) {\n\t\t\t\t\tparent.args.push(obj.key);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.terminal(/^\\s*\\)\\s*\\{/)\n\t\t\t.one('scopeBlock')\n\t\t\t.done((env, obj) => {\n\t\t\t\t// remove last uneeded '}' in catched block (it's there for inner-blocks recursion)\n\t\t\t\tobj.block = obj.block.substring(0, obj.block.length - 1);\n\t\t\t}),\n\n\t\tscopeBlock: r // function scope block (after first '{')\n\t\t\t.oneOf(\n\t\t\t\t// inner block recursion\n\t\t\t\tr.terminal(/^[^\\{\\}]*\\{/, (env, obj, cap) => {\n\t\t\t\t\tobj.block += cap[0];\n\t\t\t\t})\n\t\t\t\t.oneOrMore('scopeBlock'),\n\n\t\t\t\t// end block \n\t\t\t\tr.terminal(/^[^\\}]*\\}/, (env, obj, cap) => {\n\t\t\t\t\tobj.block += cap[0];\n\t\t\t\t})\n\t\t\t)\n\t},\n\tparser = new Parser(rules);\n\n/**\n * parse UUS string to babelute instance\n * @param  {string} string the UUS string to parse\n * @param  {Object={}} opt    options\n * @return {Babelute}      the deserialized babelute instance\n * @public\n */\nfunction fromUUS(string, opt = {}) {\n\tconst env = {};\n\tObject.assign(env, opt);\n\tenv.lexicons = [opt.mainLexic];\n\tenv.currentLexicon = opt.mainLexic || null;\n\treturn parser.parse(string, 'babelute', b(opt.mainLexic, env.asFirstLevel), env);\n}\n\nfunction getMethod(parent, name) {\n\tconst method = parent[name];\n\tif (!method)\n\t\tthrow new Error('Babelute : no lexem found in current lexicon (' + (parent.__babelute__ || 'default') + ') with :' + name);\n\treturn method;\n}\n\nexport default fromUUS;\n\n//\n\n","/**\n * @author Gilles Coomans\n * @licence MIT\n * @copyright 2016 Gilles Coomans\n */\nimport bbl from 'babelute/src/index.js';\n// serializer to Babelute DSL\nimport toUUS from './to-uus.js';\n// Babelute DSL parser\nimport fromUUS from './from-uus.js';\n\nconst babelute = bbl;\n\nbabelute.fromUUS = fromUUS;\nbabelute.toUUS = toUUS;\n\n/**\n * export babelute core ({@link https://github.com/nomocas/babelute}) decorated with fromUUS/toUUS\n * @type {Object}\n * @public\n */\nexport default babelute;"],"names":["Lexem","lexicon","name","args","Babelute","lexems","_lexems","__babelute__","lexiconName","push","condition","babelute","elseBabelute","concat","array","func","forEach","item","index","b","apply","BaseClass","api","B","call","prototype","Object","create","constructor","i","fromJSON","json","JSON","parse","k","v","map","lexem","FirstLevel","__first_level_babelute__","lexemName","arguments","Initializer","BaseInitializer","Class","createInitializer","BabeluteClass","Init","extends","initializer","_empty","keys","addToInitializer","methodName","lexicons","Lexicon","parent","Atomic","initClass","SecondLevel","secondLevel","key","atomsArray","addAtom","producer","atomicMethods","secondLevelCompounds","j","getFirstLevelMethod","methods","firstLevel","instance","Error","targets","translate","createLexicon","getLexicon","registerLexicon","_lexicon","_use","use","slice","self","split","value","init","asFirstLevel","developOneLevel","developToAtoms","Pragmatics","pragmas","_targets","addPragmas","createPragmatics","FacadePragmatics","subject","percolator","collec","itemHandler","length","len","templ","$output","createFacadeInitializer","pragmatics","Facade","_subject","_percolator","_append","createFacadePragmatics","pushLexicScope","opt","alreadyPushed","lexicScope","currentLexic","popLexicScope","pop","removeLastUndefined","arr","undefined","splice","beautyLexems","lexemsOutput","outlength","lexicPushed","out","beautyArrayValues","maxLength","replace","s","join","beautyArray","addReturn","values","valueToString","beautyObject","obj","beautyProperties","val","toUUS","beautify","arrayToString","objectToString","stringify","classCallCheck","Constructor","TypeError","createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","protoProps","staticProps","Parser","rules","defaultRule","getRule","r","string","rule","env","parser","exec","error","errorMessage","pos","posInFile","getPositionInFile","line","col","substring","_queue","current","__elenpi__","position","splitted","lineNumber","lineLength","defaultSpaceRegExp","Rule","done","callback","_r","terminal","reg","set$$1","cap","char","test","xOrMore","minimum","maximum","Infinity","pushTo","pushToString","As","as","separator","count","currentPosition","newDescriptor","restLength","skip","zeroOrMore","oneOrMore","oneOf","optional","set","setDescriptor","maybeOneOf","one","maybeOne","space","needed","end","msg","getOwnPropertyNames","elenpi","replaceSingleString","replaceDoubleString","valuePrevisuMap","currentLexicon","__swapped__","newParent","parseFloat","parseInt","NaN","acceptFunctions","Function","block","fromUUS","assign","mainLexic","getMethod","method","bbl"],"mappings":"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"}